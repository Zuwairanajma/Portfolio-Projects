/**
 * To use the HTTP server and client one must `require('node:http')`.
 *
 * The HTTP interfaces in Node.js are designed to support many features
 * of the protocol which have been traditionally difficult to use.
 * In particular, large, possibly chunk-encoded, messages. The interface is
 * careful to never buffer entire requests or responses, so the
 * user is able to stream data.
 *
 * HTTP message headers are represented by an object like this:
 *
 * ```js
 * { 'content-length': '123',
 *   'content-type': 'text/plain',
 *   'connection': 'keep-alive',
 *   'host': 'example.com',
 *   'accept': '*' }
 * ```
 *
 * Keys are lowercased. Values are not modified.
 *
 * In order to support the full spectrum of possible HTTP applications, the Node.js
 * HTTP API is very low-level. It deals with stream handling and message
 * parsing only. It parses a message into headers and body but it does not
 * parse the actual headers or the body.
 *
 * See `message.headers` for details on how duplicate headers are handled.
 *
 * The raw headers as they were received are retained in the `rawHeaders`property, which is an array of `[key, value, key2, value2, ...]`. For
 * example, the previous message header object might have a `rawHeaders`list like the following:
 *
 * ```js
 * [ 'ConTent-Length', '123456',
 *   'content-LENGTH', '123',
 *   'content-type', 'text/plain',
 *   'CONNECTION', 'keep-alive',
 *   'Host', 'example.com',
 *   'accepT', '*' ]
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/http.js)
 */
declare module 'http' {
    import * as stream from 'node:stream';
    import { URL } from 'node:url';
    import { LookupOptions } from 'node:dns';
    import { EventEmitter } from 'node:events';
    import { TcpSocketConnectOpts, Socket, Server as NetServer, LookupFunction } from 'node:net';
    // incoming headers will never contain number
    interface IncomingHttpHeaders extends NodeJS.Dict<string | string[]> {
        accept?: string | undefined;
        'accept-language'?: string | undefined;
        'accept-patch'?: string | undefined;
        'accept-ranges'?: string | undefined;
        'access-control-allow-credentials'?: string | undefined;
        'access-control-allow-headers'?: string | undefined;
        'access-control-allow-methods'?: string | undefined;
        'access-control-allow-origin'?: string | undefined;
        'access-control-expose-headers'?: string | undefined;
        'access-control-max-age'?: string | undefined;
        'access-control-request-headers'?: string | undefined;
        'access-control-request-method'?: string | undefined;
        age?: string | undefined;
        allow?: string | undefined;
        'alt-svc'?: string | undefined;
        authorization?: string | undefined;
        'cache-control'?: string | undefined;
        connection?: string | undefined;
        'content-disposition'?: string | undefined;
        'content-encoding'?: string | undefined;
        'content-language'?: string | undefined;
        'content-length'?: string | undefined;
        'content-location'?: string | undefined;
        'content-range'?: string | undefined;
        'content-type'?: string | undefined;
        cookie?: string | undefined;
        date?: string | undefined;
        etag?: string | undefined;
        expect?: string | undefined;
        expires?: string | undefined;
        forwarded?: string | undefined;
        from?: string | undefined;
        host?: string | undefined;
        'if-match'?: string | undefined;
        'if-modified-since'?: string | undefined;
        'if-none-match'?: string | undefined;
        'if-unmodified-since'?: string | undefined;
        'last-modified'?: string | undefined;
        location?: string | undefined;
        origin?: string | undefined;
        pragma?: string | undefined;
        'proxy-authenticate'?: string | undefined;
        'proxy-authorization'?: string | undefined;
        'public-key-pins'?: string | undefined;
        range?: string | undefined;
        referer?: string | undefined;
        'retry-after'?: string | undefined;
        'sec-websocket-accept'?: string | undefined;
        'sec-websocket-extensions'?: string | undefined;
        'sec-websocket-key'?: string | undefined;
        'sec-websocket-protocol'?: string | undefined;
        'sec-websocket-version'?: string | undefined;
        'set-cookie'?: string[] | undefined;
        'strict-transport-security'?: string | undefined;
        tk?: string | undefined;
        trailer?: string | undefined;
        'transfer-encoding'?: string | undefined;
        upgrade?: string | undefined;
        'user-agent'?: string | undefined;
        vary?: string | undefined;
        via?: string | undefined;
        warning?: string | undefined;
        'www-authenticate'?: string | undefined;
    }
    // outgoing headers allows numbers (as they are converted internally to strings)
    type OutgoingHttpHeader = number | string | string[];
    interface OutgoingHttpHeaders extends NodeJS.Dict<OutgoingHttpHeader> {}
    interface ClientRequestArgs {
        _defaultAgent?: Agent | undefined;
        agent?: Agent | boolean | undefined;
        auth?: string | null | undefined;
        // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L278
        createConnection?:
            | ((options: ClientRequestArgs, oncreate: (err: Error, socket: Socket) => void) => Socket)
            | undefined;
        defaultPort?: number | string | undefined;
        family?: number | undefined;
        headers?: OutgoingHttpHeaders | undefined;
        hints?: LookupOptions['hints'];
        host?: string | null | undefined;
        hostname?: string | null | undefined;
        insecureHTTPParser?: boolean | undefined;
        localAddress?: string | undefined;
        localPort?: number | undefined;
        lookup?: LookupFunction | undefined;
        /**
         * @default 16384
         */
        maxHeaderSize?: number | undefined;
        method?: string | undefined;
        path?: string | null | undefined;
        port?: number | string | null | undefined;
        protocol?: string | null | undefined;
        setHost?: boolean | undefined;
        signal?: AbortSignal | undefined;
        socketPath?: string | undefined;
        timeout?: number | undefined;
        uniqueHeaders?: Array<string | string[]> | undefined;
        joinDuplicateHeaders?: boolean;
    }
    interface ServerOptions<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse = typeof ServerResponse,
    > {
        /**
         * Specifies the `IncomingMessage` class to be used. Useful for extending the original `IncomingMessage`.
         */
        IncomingMessage?: Request | undefined;
        /**
         * Specifies the `ServerResponse` class to be used. Useful for extending the original `ServerResponse`.
         */
        ServerResponse?: Response | undefined;
        /**
         * Sets the timeout value in milliseconds for receiving the entire request from the client.
         * @see Server.requestTimeout for more information.
         * @default 300000
         * @since v18.0.0
         */
        requestTimeout?: number | undefined;
        /**
         * It joins the field line values of multiple headers in a request with `, ` instead of discarding the duplicates.
         * @default false
         * @since v18.14.0
         */
        joinDuplicateHeaders?: boolean;
        /**
         * The number of milliseconds of inactivity a server needs to wait for additional incoming data,
         * after it has finished writing the last response, before a socket will be destroyed.
         * @see Server.keepAliveTimeout for more information.
         * @default 5000
         * @since v18.0.0
         */
        keepAliveTimeout?: number | undefined;
        /**
         * Sets the interval value in milliseconds to check for request and headers timeout in incomplete requests.
         * @default 30000
         */
        connectionsCheckingInterval?: number | undefined;
        /**
         * Optionally overrides all `socket`s' `readableHighWaterMark` and `writableHighWaterMark`.
         * This affects `highWaterMark` property of both `IncomingMessage` and `ServerResponse`.
         * Default: @see stream.getDefaultHighWaterMark().
         * @since v20.1.0
         */
        highWaterMark?: number | undefined;
        /**
         * Use an insecure HTTP parser that accepts invalid HTTP headers when `true`.
         * Using the insecure parser should be avoided.
         * See --insecure-http-parser for more information.
         * @default false
         */
        insecureHTTPParser?: boolean | undefined;
        /**
         * Optionally overrides the value of
         * `--max-http-header-size` for requests received by this server, i.e.
         * the maximum length of request headers in bytes.
         * @default 16384
         * @since v13.3.0
         */
        maxHeaderSize?: number | undefined;
        /**
         * If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.
         * @default true
         * @since v16.5.0
         */
        noDelay?: boolean | undefined;
        /**
         * If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,
         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.
         * @default false
         * @since v16.5.0
         */
        keepAlive?: boolean | undefined;
        /**
         * If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.
         * @default 0
         * @since v16.5.0
         */
        keepAliveInitialDelay?: number | undefined;
        /**
         * A list of response headers that should be sent only once.
         * If the header's value is an array, the items will be joined using `; `.
         */
        uniqueHeaders?: Array<string | string[]> | undefined;
    }
    type RequestListener<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse = typeof ServerResponse,
    > = (req: InstanceType<Request>, res: InstanceType<Response> & { req: InstanceType<Request> }) => void;
    /**
     * @since v0.1.17
     */
    class Server<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse = typeof ServerResponse,
    > extends NetServer {
        constructor(requestListener?: RequestListener<Request, Response>);
        constructor(options: ServerOptions<Request, Response>, requestListener?: RequestListener<Request, Response>);
        /**
         * Sets the timeout value for sockets, and emits a `'timeout'` event on
         * the Server object, passing the socket as an argument, if a timeout
         * occurs.
         *
         * If there is a `'timeout'` event listener on the Server object, then it
         * will be called with the timed-out socket as an argument.
         *
         * By default, the Server does not timeout sockets. However, if a callback
         * is assigned to the Server's `'timeout'` event, timeouts must be handled
         * explicitly.
         * @since v0.9.12
         * @param [msecs=0 (no timeout)]
         */
        setTimeout(msecs?: number, callback?: () => void): this;
        setTimeout(callback: () => void): this;
        /**
         * Limits maximum incoming headers count. If set to 0, no limit will be applied.
         * @since v0.7.0
         */
        maxHeadersCount: number | null;
        /**
         * The maximum number of requests socket can handle
         * before closing keep alive connection.
         *
         * A value of `0` will disable the limit.
         *
         * When the limit is reached it will set the `Connection` header value to `close`,
         * but will not actually close the connection, subsequent requests sent
         * after the limit is reached will get `503 Service Unavailable` as a response.
         * @since v16.10.0
         */
        maxRequestsPerSocket: number | null;
        /**
         * The number of milliseconds of inactivity before a socket is presumed
         * to have timed out.
         *
         * A value of `0` will disable the timeout behavior on incoming connections.
         *
         * The socket timeout logic is set up on connection, so changing this
         * value only affects new connections to the server, not any existing connections.
         * @since v0.9.12
         */
        timeout: number;
        /**
         * Limit the amount of time the parser will wait to receive the complete HTTP
         * headers.
         *
         * If the timeout expires, the server responds with status 408 without
         * forwarding the request to the request listener and then closes the connection.
         *
         * It must be set to a non-zero value (e.g. 120 seconds) to protect against
         * potential Denial-of-Service attacks in case the server is deployed without a
         * reverse proxy in front.
         * @since v11.3.0, v10.14.0
         */
        headersTimeout: number;
        /**
         * The number of milliseconds of inactivity a server needs to wait for additional
         * incoming data, after it has finished writing the last response, before a socket
         * will be destroyed. If the server receives new data before the keep-alive
         * timeout has fired, it will reset the regular inactivity timeout, i.e.,`server.timeout`.
         *
         * A value of `0` will disable the keep-alive timeout behavior on incoming
         * connections.
         * A value of `0` makes the http server behave similarly to Node.js versions prior
         * to 8.0.0, which did not have a keep-alive timeout.
         *
         * The socket timeout logic is set up on connection, so changing this value only
         * affects new connections to the server, not any existing connections.
         * @since v8.0.0
         */
        keepAliveTimeout: number;
        /**
         * Sets the timeout value in milliseconds for receiving the entire request from
         * the client.
         *
         * If the timeout expires, the server responds with status 408 without
         * forwarding the request to the request listener and then closes the connection.
         *
         * It must be set to a non-zero value (e.g. 120 seconds) to protect against
         * potential Denial-of-Service attacks in case the server is deployed without a
         * reverse proxy in front.
         * @since v14.11.0
         */
        requestTimeout: number;
        /**
         * Closes all connections connected to this server.
         * @since v18.2.0
         */
        closeAllConnections(): void;
        /**
         * Closes all connections connected to this server which are not sending a request
         * or waiting for a response.
         * @since v18.2.0
         */
        closeIdleConnections(): void;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'connection', listener: (socket: Socket) => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: 'listening', listener: () => void): this;
        addListener(event: 'checkContinue', listener: RequestListener<Request, Response>): this;
        addListener(event: 'checkExpectation', listener: RequestListener<Request, Response>): this;
        addListener(event: 'clientError', listener: (err: Error, socket: stream.Duplex) => void): this;
        addListener(event: 'connect', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        addListener(event: 'dropRequest', listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        addListener(event: 'request', listener: RequestListener<Request, Response>): this;
        addListener(event: 'upgrade', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: 'close'): boolean;
        emit(event: 'connection', socket: Socket): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: 'listening'): boolean;
        emit(
            event: 'checkContinue',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(
            event: 'checkExpectation',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: 'clientError', err: Error, socket: stream.Duplex): boolean;
        emit(event: 'connect', req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;
        emit(event: 'dropRequest', req: InstanceType<Request>, socket: stream.Duplex): boolean;
        emit(
            event: 'request',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: 'upgrade', req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: 'close', listener: () => void): this;
        on(event: 'connection', listener: (socket: Socket) => void): this;
        on(event: 'error', listener: (err: Error) => void): this;
        on(event: 'listening', listener: () => void): this;
        on(event: 'checkContinue', listener: RequestListener<Request, Response>): this;
        on(event: 'checkExpectation', listener: RequestListener<Request, Response>): this;
        on(event: 'clientError', listener: (err: Error, socket: stream.Duplex) => void): this;
        on(event: 'connect', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        on(event: 'dropRequest', listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        on(event: 'request', listener: RequestListener<Request, Response>): this;
        on(event: 'upgrade', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'connection', listener: (socket: Socket) => void): this;
        once(event: 'error', listener: (err: Error) => void): this;
        once(event: 'listening', listener: () => void): this;
        once(event: 'checkContinue', listener: RequestListener<Request, Response>): this;
        once(event: 'checkExpectation', listener: RequestListener<Request, Response>): this;
        once(event: 'clientError', listener: (err: Error, socket: stream.Duplex) => void): this;
        once(event: 'connect', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        once(event: 'dropRequest', listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        once(event: 'request', listener: RequestListener<Request, Response>): this;
        once(event: 'upgrade', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'connection', listener: (socket: Socket) => void): this;
        prependListener(event: 'error', listener: (err: Error) => void): this;
        prependListener(event: 'listening', listener: () => void): this;
        prependListener(event: 'checkContinue', listener: RequestListener<Request, Response>): this;
        prependListener(event: 'checkExpectation', listener: RequestListener<Request, Response>): this;
        prependListener(event: 'clientError', listener: (err: Error, socket: stream.Duplex) => void): this;
        prependListener(event: 'connect', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        prependListener(event: 'dropRequest', listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        prependListener(event: 'request', listener: RequestListener<Request, Response>): this;
        prependListener(event: 'upgrade', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'connection', listener: (socket: Socket) => void): this;
        prependOnceListener(event: 'error', listener: (err: Error) => void): this;
        prependOnceListener(event: 'listening', listener: () => void): this;
        prependOnceListener(event: 'checkContinue', listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: 'checkExpectation', listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: 'clientError', listener: (err: Error, socket: stream.Duplex) => void): this;
        prependOnceListener(event: 'connect', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        prependOnceListener(event: 'dropRequest', listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        prependOnceListener(event: 'request', listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: 'upgrade', listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
    }
    /**
     * This class serves as the parent class of {@link ClientRequest} and {@link ServerResponse}. It is an abstract outgoing message from
     * the perspective of the participants of an HTTP transaction.
     * @since v0.1.17
     */
    class OutgoingMessage<Request extends IncomingMessage = IncomingMessage> extends stream.Writable {
        readonly req: Request;
        chunkedEncoding: boolean;
        shouldKeepAlive: boolean;
        useChunkedEncodingByDefault: boolean;
        sendDate: boolean;
        /**
         * @deprecated Use `writableEnded` instead.
         */
        finished: boolean;
        /**
         * Read-only. `true` if the headers were sent, otherwise `false`.
         * @since v0.9.3
         */
        readonly headersSent: boolean;
        /**
         * Alias of `outgoingMessage.socket`.
         * @since v0.3.0
         * @deprecated Since v15.12.0,v14.17.1 - Use `socket` instead.
         */
        readonly connection: Socket | null;
        /**
         * Reference to the underlying socket. Usually, users will not want to access
         * this property.
         *
         * After calling `outgoingMessage.end()`, this property will be nulled.
         * @since v0.3.0
         */
        readonly socket: Socket | null;
        constructor();
        /**
         * Once a socket is associated with the message and is connected,`socket.setTimeout()` will be called with `msecs` as the first parameter.
         * @since v0.9.12
         * @param callback Optional function to be called when a timeout occurs. Same as binding to the `timeout` event.
         */
        setTimeout(msecs: number, callback?: () => void): this;
        /**
         * Sets a single header value. If the header already exists in the to-be-sent
         * headers, its value will be replaced. Use an array of strings to send multiple
         * headers with the same name.
         * @since v0.4.0
         * @param name Header name
         * @param value Header value
         */
        setHeader(name: string, value: number | string | ReadonlyArray<string>): this;
        /**
         * Append a single header value for the header object.
         *
         * If the value is an array, this is equivalent of calling this method multiple
         * times.
         *
         * If there were no previous value for the header, this is equivalent of calling `outgoingMessage.setHeader(name, value)`.
         *
         * Depending of the value of `options.uniqueHeaders` when the client request or the
         * server were created, this will end up in the header being sent multiple times or
         * a single time with values joined using `; `.
         * @since v18.3.0, v16.17.0
         * @param name Header name
         * @param value Header value
         */
        appendHeader(name: string, value: string | ReadonlyArray<string>): this;
        /**
         * Gets the value of the HTTP header with the given name. If that header is not
         * set, the returned value will be `undefined`.
         * @since v0.4.0
         * @param name Name of header
         */
        getHeader(name: string): number | string | string[] | undefined;
        /**
         * Returns a shallow copy of the current outgoing headers. Since a shallow
         * copy is used, array values may be mutated without additional calls to
         * various header-related HTTP module methods. The keys of the returned
         * object are the header names and the values are the respective header
         * values. All header names are lowercase.
         *
         * The object returned by the `outgoingMessage.getHeaders()` method does
         * not prototypically inherit from the JavaScript `Object`. This means that
         * typical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,
         * and others are not defined and will not work.
         *
         * ```js
         * outgoingMessage.setHeader('Foo', 'bar');
         * outgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headers = outgoingMessage.getHeaders();
         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
         * ```
         * @since v7.7.0
         */
        getHeaders(): OutgoingHttpHeaders;
        /**
         * Returns an array containing the unique names of the current outgoing headers.
         * All names are lowercase.
         * @since v7.7.0
         */
        getHeaderNames(): string[];
        /**
         * Returns `true` if the header identified by `name` is currently set in the
         * outgoing headers. The header name is case-insensitive.
         *
         * ```js
         * const hasContentType = outgoingMessage.hasHeader('content-type');
         * ```
         * @since v7.7.0
         */
        hasHeader(name: string): boolean;
        /**
         * Removes a header that is queued for implicit sending.
         *
         * ```js
         * outgoingMessage.removeHeader('Content-Encoding');
         * ```
         * @since v0.4.0
         * @param name Header name
         */
        removeHeader(name: string): void;
        /**
         * Adds HTTP trailers (headers but at the end of the message) to the message.
         *
         * Trailers will **only** be emitted if the message is chunked encoded. If not,
         * the trailers will be silently discarded.
         *
         * HTTP requires the `Trailer` header to be sent to emit trailers,
         * with a list of header field names in its value, e.g.
         *
         * ```js
         * message.writeHead(200, { 'Content-Type': 'text/plain',
         *                          'Trailer': 'Content-MD5' });
         * message.write(fileData);
         * message.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });
         * message.end();
         * ```
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         * @since v0.3.0
         */
        addTrailers(headers: OutgoingHttpHeaders | ReadonlyArray<[string, string]>): void;
        /**
         * Flushes the message headers.
         *
         * For efficiency reason, Node.js normally buffers the message headers
         * until `outgoingMessage.end()` is called or the first chunk of message data
         * is written. It then tries to pack the headers and data into a single TCP
         * packet.
         *
         * It is usually desired (it saves a TCP round-trip), but not when the first
         * data is not sent until possibly much later. `outgoingMessage.flushHeaders()`bypasses the optimization and kickstarts the message.
         * @since v1.6.0
         */
        flushHeaders(): void;
    }
    /**
     * This object is created internally by an HTTP server, not by the user. It is
     * passed as the second parameter to the `'request'` event.
     * @since v0.1.17
     */
    class ServerResponse<Request extends IncomingMessage = IncomingMessage> extends OutgoingMessage<Request> {
        /**
         * When using implicit headers (not calling `response.writeHead()` explicitly),
         * this property controls the status code that will be sent to the client when
         * the headers get flushed.
         *
         * ```js
         * response.statusCode = 404;
         * ```
         *
         * After response header was sent to the client, this property indicates the
         * status code which was sent out.
         * @since v0.4.0
         */
        statusCode: number;
        /**
         * When using implicit headers (not calling `response.writeHead()` explicitly),
         * this property controls the status message that will be sent to the client when
         * the headers get flushed. If this is left as `undefined` then the standard
         * message for the status code will be used.
         *
         * ```js
         * response.statusMessage = 'Not found';
         * ```
         *
         * After response header was sent to the client, this property indicates the
         * status message which was sent out.
         * @since v0.11.8
         */
        statusMessage: string;
        /**
         * If set to `true`, Node.js will check whether the `Content-Length`header value and the size of the body, in bytes, are equal.
         * Mismatching the `Content-Length` header value will result
         * in an `Error` being thrown, identified by `code:``'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`.
         * @since v18.10.0, v16.18.0
         */
        strictContentLength: boolean;
        constructor(req: Request);
        assignSocket(socket: Socket): void;
        detachSocket(socket: Socket): void;
        /**
         * Sends an HTTP/1.1 100 Continue message to the client, indicating that
         * the request body should be sent. See the `'checkContinue'` event on`Server`.
         * @since v0.3.0
         */
        writeContinue(callback?: () => void): void;
        /**
         * Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,
         * indicating that the user agent can preload/preconnect the linked resources.
         * The `hints` is an object containing the values of headers to be sent with
         * early hints message. The optional `callback` argument will be called when
         * the response message has been written.
         *
         * **Example**
         *
         * ```js
         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';
         * response.writeEarlyHints({
         *   'link': ea